{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\n\nvar _react = require('react');\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\n\nfunction getChildMapping(children) {\n  if (!children) {\n    return children;\n  }\n\n  var result = {};\n\n  _react.Children.map(children, function (child) {\n    return child;\n  }).forEach(function (child) {\n    result[child.key] = child;\n  });\n\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    if (next.hasOwnProperty(key)) {\n      return next[key];\n    }\n\n    return prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = {};\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}","map":{"version":3,"sources":["/home/sujay/Documents/Bedansh Blog/Mind-Space-React/node_modules/react-transition-group/utils/ChildMapping.js"],"names":["exports","__esModule","getChildMapping","mergeChildMappings","_react","require","children","result","Children","map","child","forEach","key","prev","next","getValueForKey","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAF,OAAO,CAACG,kBAAR,GAA6BA,kBAA7B;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASH,eAAT,CAAyBI,QAAzB,EAAmC;AACjC,MAAI,CAACA,QAAL,EAAe;AACb,WAAOA,QAAP;AACD;;AACD,MAAIC,MAAM,GAAG,EAAb;;AACAH,EAAAA,MAAM,CAACI,QAAP,CAAgBC,GAAhB,CAAoBH,QAApB,EAA8B,UAAUI,KAAV,EAAiB;AAC7C,WAAOA,KAAP;AACD,GAFD,EAEGC,OAFH,CAEW,UAAUD,KAAV,EAAiB;AAC1BH,IAAAA,MAAM,CAACG,KAAK,CAACE,GAAP,CAAN,GAAoBF,KAApB;AACD,GAJD;;AAKA,SAAOH,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASJ,kBAAT,CAA4BU,IAA5B,EAAkCC,IAAlC,EAAwC;AACtCD,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAC,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,WAASC,cAAT,CAAwBH,GAAxB,EAA6B;AAC3B,QAAIE,IAAI,CAACE,cAAL,CAAoBJ,GAApB,CAAJ,EAA8B;AAC5B,aAAOE,IAAI,CAACF,GAAD,CAAX;AACD;;AAED,WAAOC,IAAI,CAACD,GAAD,CAAX;AACD,GAVqC,CAYtC;AACA;;;AACA,MAAIK,eAAe,GAAG,EAAtB;AAEA,MAAIC,WAAW,GAAG,EAAlB;;AACA,OAAK,IAAIC,OAAT,IAAoBN,IAApB,EAA0B;AACxB,QAAIC,IAAI,CAACE,cAAL,CAAoBG,OAApB,CAAJ,EAAkC;AAChC,UAAID,WAAW,CAACE,MAAhB,EAAwB;AACtBH,QAAAA,eAAe,CAACE,OAAD,CAAf,GAA2BD,WAA3B;AACAA,QAAAA,WAAW,GAAG,EAAd;AACD;AACF,KALD,MAKO;AACLA,MAAAA,WAAW,CAACG,IAAZ,CAAiBF,OAAjB;AACD;AACF;;AAED,MAAIG,CAAC,GAAG,KAAK,CAAb;AACA,MAAIC,YAAY,GAAG,EAAnB;;AACA,OAAK,IAAIC,OAAT,IAAoBV,IAApB,EAA0B;AACxB,QAAIG,eAAe,CAACD,cAAhB,CAA+BQ,OAA/B,CAAJ,EAA6C;AAC3C,WAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,eAAe,CAACO,OAAD,CAAf,CAAyBJ,MAAzC,EAAiDE,CAAC,EAAlD,EAAsD;AACpD,YAAIG,cAAc,GAAGR,eAAe,CAACO,OAAD,CAAf,CAAyBF,CAAzB,CAArB;AACAC,QAAAA,YAAY,CAACN,eAAe,CAACO,OAAD,CAAf,CAAyBF,CAAzB,CAAD,CAAZ,GAA4CP,cAAc,CAACU,cAAD,CAA1D;AACD;AACF;;AACDF,IAAAA,YAAY,CAACC,OAAD,CAAZ,GAAwBT,cAAc,CAACS,OAAD,CAAtC;AACD,GAtCqC,CAwCtC;;;AACA,OAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,WAAW,CAACE,MAA5B,EAAoCE,CAAC,EAArC,EAAyC;AACvCC,IAAAA,YAAY,CAACL,WAAW,CAACI,CAAD,CAAZ,CAAZ,GAA+BP,cAAc,CAACG,WAAW,CAACI,CAAD,CAAZ,CAA7C;AACD;;AAED,SAAOC,YAAP;AACD","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\n\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children) {\n  if (!children) {\n    return children;\n  }\n  var result = {};\n  _react.Children.map(children, function (child) {\n    return child;\n  }).forEach(function (child) {\n    result[child.key] = child;\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    if (next.hasOwnProperty(key)) {\n      return next[key];\n    }\n\n    return prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = {};\n\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}"]},"metadata":{},"sourceType":"script"}